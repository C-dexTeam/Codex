// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: userProfile.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const changeUserLevel = `-- name: ChangeUserLevel :one
UPDATE
    t_users_profile
SET
    level = COALESCE($1::INTEGER, level),
    experience = COALESCE($2::INTEGER, experience),
    next_level_Exp = COALESCE($3::INTEGER, next_level_Exp)
WHERE
    id = $4
RETURNING
    level, experience, next_level_Exp
`

type ChangeUserLevelParams struct {
	Level         sql.NullInt32
	Experience    sql.NullInt32
	NextLevelExp  sql.NullInt32
	UserProfileID uuid.UUID
}

type ChangeUserLevelRow struct {
	Level        sql.NullInt32
	Experience   sql.NullInt32
	NextLevelExp sql.NullInt32
}

func (q *Queries) ChangeUserLevel(ctx context.Context, arg ChangeUserLevelParams) (ChangeUserLevelRow, error) {
	row := q.db.QueryRowContext(ctx, changeUserLevel,
		arg.Level,
		arg.Experience,
		arg.NextLevelExp,
		arg.UserProfileID,
	)
	var i ChangeUserLevelRow
	err := row.Scan(&i.Level, &i.Experience, &i.NextLevelExp)
	return i, err
}

const changeUserRole = `-- name: ChangeUserRole :exec
UPDATE
    t_users_profile
SET
    role_id = $1
WHERE
    id = $2
`

type ChangeUserRoleParams struct {
	RoleID        uuid.UUID
	UserProfileID uuid.UUID
}

func (q *Queries) ChangeUserRole(ctx context.Context, arg ChangeUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, changeUserRole, arg.RoleID, arg.UserProfileID)
	return err
}

const createUserProfile = `-- name: CreateUserProfile :one
INSERT INTO
    t_users_profile (user_auth_id, role_id, name, surname)
VALUES
    ($1, $2, $3, $4)
RETURNING id
`

type CreateUserProfileParams struct {
	UserAuthID uuid.UUID
	RoleID     uuid.UUID
	Name       sql.NullString
	Surname    sql.NullString
}

func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserProfile,
		arg.UserAuthID,
		arg.RoleID,
		arg.Name,
		arg.Surname,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT 
    up.id, up.user_auth_id, up.role_id, up.name, up.surname, up.level, up.experience, up.next_level_exp, up.streak, up.last_streak_date, up.created_at, up.deleted_at 
FROM 
    t_users_profile as up
WHERE
    up.id = $1
`

func (q *Queries) GetUserProfile(ctx context.Context, id uuid.UUID) (TUsersProfile, error) {
	row := q.db.QueryRowContext(ctx, getUserProfile, id)
	var i TUsersProfile
	err := row.Scan(
		&i.ID,
		&i.UserAuthID,
		&i.RoleID,
		&i.Name,
		&i.Surname,
		&i.Level,
		&i.Experience,
		&i.NextLevelExp,
		&i.Streak,
		&i.LastStreakDate,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUsersProfile = `-- name: GetUsersProfile :many
SELECT up.id, up.user_auth_id, up.role_id, up.name, up.surname, up.level, up.experience, up.next_level_exp,
       up.streak, up.last_streak_date, up.created_at, up.deleted_at 
FROM t_users_profile as up
WHERE
    ($1::UUID IS NULL OR up.id = $1::UUID) AND
    ($2::UUID IS NULL OR up.user_auth_id = $2::UUID) AND
    ($3::UUID IS NULL OR up.role_id = $3::UUID) AND
    ($4::TEXT IS NULL OR up.name ILIKE '%' || $4::TEXT || '%') AND
    ($5::TEXT IS NULL OR up.surname ILIKE '%' || $5::TEXT || '%') AND
    ($6::INTEGER IS NULL OR up.level = $6::INTEGER) AND
    ($7::INTEGER IS NULL OR up.experience = $7::INTEGER) AND
    ($8::INTEGER IS NULL OR up.next_level_exp = $8::INTEGER)
LIMIT $10 OFFSET $9
`

type GetUsersProfileParams struct {
	ID           uuid.NullUUID
	UserAuthID   uuid.NullUUID
	RoleID       uuid.NullUUID
	Name         sql.NullString
	Surname      sql.NullString
	Level        sql.NullInt32
	Experience   sql.NullInt32
	NextLevelExp sql.NullInt32
	Off          int32
	Lim          int32
}

func (q *Queries) GetUsersProfile(ctx context.Context, arg GetUsersProfileParams) ([]TUsersProfile, error) {
	rows, err := q.db.QueryContext(ctx, getUsersProfile,
		arg.ID,
		arg.UserAuthID,
		arg.RoleID,
		arg.Name,
		arg.Surname,
		arg.Level,
		arg.Experience,
		arg.NextLevelExp,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUsersProfile
	for rows.Next() {
		var i TUsersProfile
		if err := rows.Scan(
			&i.ID,
			&i.UserAuthID,
			&i.RoleID,
			&i.Name,
			&i.Surname,
			&i.Level,
			&i.Experience,
			&i.NextLevelExp,
			&i.Streak,
			&i.LastStreakDate,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUserProfile = `-- name: SoftDeleteUserProfile :exec
UPDATE
    t_users_profile
SET
    deleted_at = CURRENT_TIMESTAMP
WHERE
    id = $1
`

func (q *Queries) SoftDeleteUserProfile(ctx context.Context, userProfileID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteUserProfile, userProfileID)
	return err
}

const streakUp = `-- name: StreakUp :one
UPDATE
    t_users_profile
SET
    streak = streak + 1, last_streak_date = CURRENT_TIMESTAMP
WHERE
    id = $1
RETURNING streak
`

func (q *Queries) StreakUp(ctx context.Context, userProfileID uuid.UUID) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, streakUp, userProfileID)
	var streak sql.NullInt32
	err := row.Scan(&streak)
	return streak, err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE
    t_users_profile
SET
    name = COALESCE($1::TEXT, name),
    surname =  COALESCE($2::TEXT, surname)
WHERE
    id = $3
`

type UpdateUserProfileParams struct {
	Name          sql.NullString
	Surname       sql.NullString
	UserProfileID uuid.UUID
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.ExecContext(ctx, updateUserProfile, arg.Name, arg.Surname, arg.UserProfileID)
	return err
}

const userStatistic = `-- name: UserStatistic :one
SELECT
    COUNT(DISTINCT uc.course_id) AS total_enrolled_courses,
    COUNT(DISTINCT uc.course_id) FILTER (WHERE uc.progress = 100) AS completed_courses,
    COUNT(DISTINCT ch.chapter_id) AS total_enrolled_chapters,
    COUNT(DISTINCT ch.chapter_id) FILTER (WHERE ch.isFinished = TRUE) AS completed_chapters
FROM 
    t_user_courses uc
INNER JOIN 
    t_user_chapters ch ON uc.user_auth_id = ch.user_auth_id
WHERE 
    uc.user_auth_id = $1
`

type UserStatisticRow struct {
	TotalEnrolledCourses  int64
	CompletedCourses      int64
	TotalEnrolledChapters int64
	CompletedChapters     int64
}

func (q *Queries) UserStatistic(ctx context.Context, userAuthID uuid.UUID) (UserStatisticRow, error) {
	row := q.db.QueryRowContext(ctx, userStatistic, userAuthID)
	var i UserStatisticRow
	err := row.Scan(
		&i.TotalEnrolledCourses,
		&i.CompletedCourses,
		&i.TotalEnrolledChapters,
		&i.CompletedChapters,
	)
	return i, err
}
