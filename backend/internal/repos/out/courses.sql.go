// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: courses.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkCourseByID = `-- name: CheckCourseByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_courses AS l
        WHERE l.id = $1 AND l.deleted_at IS NULL
    ) THEN true
    ELSE false
END AS exists
`

func (q *Queries) CheckCourseByID(ctx context.Context, courseID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkCourseByID, courseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCourse = `-- name: CreateCourse :one
INSERT INTO
    t_courses (language_id, programming_language_id, reward_id, reward_amount, title, description, image_path)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateCourseParams struct {
	LanguageID            uuid.UUID
	ProgrammingLanguageID uuid.NullUUID
	RewardID              uuid.NullUUID
	RewardAmount          int32
	Title                 string
	Description           string
	ImagePath             string
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createCourse,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.ImagePath,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getCourse = `-- name: GetCourse :one
SELECT 
    c.id, c.language_id, c.programming_language_id, c.reward_id, c.reward_amount, c.title,
    c.description, c.image_path, 
    (SELECT COUNT(*) FROM t_chapters as ch WHERE ch.course_id = c.id) as chapter_count,
    c.created_at, c.deleted_at
FROM 
    t_courses as c
WHERE
    c.id = $1
`

type GetCourseRow struct {
	ID                    uuid.UUID
	LanguageID            uuid.UUID
	ProgrammingLanguageID uuid.NullUUID
	RewardID              uuid.NullUUID
	RewardAmount          int32
	Title                 string
	Description           string
	ImagePath             string
	ChapterCount          int64
	CreatedAt             sql.NullTime
	DeletedAt             sql.NullTime
}

func (q *Queries) GetCourse(ctx context.Context, courseID uuid.UUID) (GetCourseRow, error) {
	row := q.db.QueryRowContext(ctx, getCourse, courseID)
	var i GetCourseRow
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.ProgrammingLanguageID,
		&i.RewardID,
		&i.RewardAmount,
		&i.Title,
		&i.Description,
		&i.ImagePath,
		&i.ChapterCount,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :many
SELECT 
    c.id, c.language_id, c.programming_language_id, c.reward_id, c.reward_amount, c.title,
    c.description, c.image_path, 
    (SELECT COUNT(*) FROM t_chapters as ch WHERE ch.course_id = c.id) as chapter_count,
    c.created_at, c.deleted_at
FROM 
    t_courses as c
WHERE
    ($1::UUID IS NULL OR c.id = $1::UUID) AND
    ($2::UUID IS NULL OR c.language_id = $2::UUID) AND
    ($3::UUID IS NULL OR c.programming_language_id = $3::UUID) AND
    ($4::UUID IS NULL OR c.reward_id = $4:: UUID) AND
    ($5::text IS NULL OR c.title ILIKE '%' || $5::text || '%') AND
    deleted_at IS NULL
LIMIT $7 OFFSET $6
`

type GetCoursesParams struct {
	ID                    uuid.NullUUID
	LanguageID            uuid.NullUUID
	ProgrammingLanguageID uuid.NullUUID
	RewardID              uuid.NullUUID
	Title                 sql.NullString
	Off                   int32
	Lim                   int32
}

type GetCoursesRow struct {
	ID                    uuid.UUID
	LanguageID            uuid.UUID
	ProgrammingLanguageID uuid.NullUUID
	RewardID              uuid.NullUUID
	RewardAmount          int32
	Title                 string
	Description           string
	ImagePath             string
	ChapterCount          int64
	CreatedAt             sql.NullTime
	DeletedAt             sql.NullTime
}

func (q *Queries) GetCourses(ctx context.Context, arg GetCoursesParams) ([]GetCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourses,
		arg.ID,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.Title,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesRow
	for rows.Next() {
		var i GetCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.ProgrammingLanguageID,
			&i.RewardID,
			&i.RewardAmount,
			&i.Title,
			&i.Description,
			&i.ImagePath,
			&i.ChapterCount,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCourse = `-- name: SoftDeleteCourse :exec
UPDATE
    t_courses
SET
    deleted_at = CURRENT_TIMESTAMP
WHERE  
    id = $1
`

func (q *Queries) SoftDeleteCourse(ctx context.Context, courseID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteCourse, courseID)
	return err
}

const updateCourse = `-- name: UpdateCourse :exec
UPDATE
    t_courses
SET
    language_id =  COALESCE($1::UUID, language_id),
    programming_language_id =  COALESCE($2::UUID, programming_language_id),
    reward_id =  COALESCE($3::UUID, reward_id),
    reward_amount =  COALESCE($4::INTEGER, reward_amount),
    title =  COALESCE($5::TEXT, title),
    description =  COALESCE($6::TEXT, description),
    image_path =  COALESCE($7::TEXT, image_path)
WHERE
    id = $8
`

type UpdateCourseParams struct {
	LanguageID            uuid.NullUUID
	ProgrammingLanguageID uuid.NullUUID
	RewardID              uuid.NullUUID
	RewardAmount          sql.NullInt32
	Title                 sql.NullString
	Description           sql.NullString
	ImagePath             sql.NullString
	CourseID              uuid.UUID
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) error {
	_, err := q.db.ExecContext(ctx, updateCourse,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.ImagePath,
		arg.CourseID,
	)
	return err
}
