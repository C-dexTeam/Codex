// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: courses.sql

package repo

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createCourse = `-- name: CreateCourse :exec
INSERT INTO
    t_courses (language_id, programming_language_id, reward_id, reward_amount, title, description, image_path)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
`

type CreateCourseParams struct {
	LanguageID            uuid.UUID
	ProgrammingLanguageID uuid.UUID
	RewardID              uuid.NullUUID
	RewardAmount          int32
	Title                 sql.NullString
	Description           sql.NullString
	ImagePath             sql.NullString
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) error {
	_, err := q.db.ExecContext(ctx, createCourse,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.ImagePath,
	)
	return err
}

const getCourseByID = `-- name: GetCourseByID :many
SELECT 
    c.id, 
    c.language_id, 
    c.programming_language_id, 
    c.reward_id, 
    c.reward_amount, 
    c.title,
    c.description, 
    c.created_at, 
    c.deleted_at,
    (
        SELECT 
            json_agg(
                json_build_object(
                    'id', ch.id,
                    'language_id', ch.language_id,
                    'reward_id', ch.reward_id,
                    'reward_amount', ch.reward_amount,
                    'title', ch.title,
                    'description', ch.description,
                    'content', ch.content,
                    'func_name', ch.func_name,
                    'frontend_template', ch.frontend_template,
                    'docker_template', ch.docker_template,
                    'check_template', ch.check_template,
                    'grants_experience', ch.grants_experience,
                    'active', ch.active,
                    'created_at', ch.created_at,
                    'deleted_at', ch.deleted_at
                )
            )
        FROM 
            t_chapters as ch
        WHERE 
            ch.course_id = c.id
        LIMIT $2 OFFSET $1
    ) AS chapters
FROM 
    t_courses as c
WHERE
    c.id = $3
`

type GetCourseByIDParams struct {
	Off      int32
	Lim      int32
	CourseID uuid.UUID
}

type GetCourseByIDRow struct {
	ID                    uuid.UUID
	LanguageID            uuid.UUID
	ProgrammingLanguageID uuid.UUID
	RewardID              uuid.NullUUID
	RewardAmount          int32
	Title                 sql.NullString
	Description           sql.NullString
	CreatedAt             sql.NullTime
	DeletedAt             sql.NullTime
	Chapters              json.RawMessage
}

func (q *Queries) GetCourseByID(ctx context.Context, arg GetCourseByIDParams) ([]GetCourseByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourseByID, arg.Off, arg.Lim, arg.CourseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseByIDRow
	for rows.Next() {
		var i GetCourseByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.ProgrammingLanguageID,
			&i.RewardID,
			&i.RewardAmount,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Chapters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourses = `-- name: GetCourses :many
SELECT 
    c.id, c.language_id, c.programming_language_id, c.reward_id, c.reward_amount, c.title,
    c.description, c.image_path, c.created_at, c.deleted_at
FROM 
    t_courses as c
WHERE
    ($1::text IS NULL OR c.id = $1) AND
    ($2::text IS NULL OR c.language_id = $2) AND
    ($3::text IS NULL OR c.programming_language_id = $3) AND
    ($4::text IS NULL OR c.reward_id = $4) AND
    ($5::text IS NULL OR title ILIKE '%' || $5::text || '%') AND
    ($6::text IS NULL OR description ILIKE '%' || $6::text || '%') AND
    deleted_at IS NULL
LIMIT $8 OFFSET $7
`

type GetCoursesParams struct {
	ID                    sql.NullString
	LanguageID            sql.NullString
	ProgrammingLanguageID sql.NullString
	RewardID              sql.NullString
	Title                 sql.NullString
	Description           sql.NullString
	Off                   int32
	Lim                   int32
}

func (q *Queries) GetCourses(ctx context.Context, arg GetCoursesParams) ([]TCourse, error) {
	rows, err := q.db.QueryContext(ctx, getCourses,
		arg.ID,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.Title,
		arg.Description,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TCourse
	for rows.Next() {
		var i TCourse
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.ProgrammingLanguageID,
			&i.RewardID,
			&i.RewardAmount,
			&i.Title,
			&i.Description,
			&i.ImagePath,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCourse = `-- name: SoftDeleteCourse :exec
UPDATE
    t_courses
SET
    deleted_at = $1
WHERE  
    id = $2
`

type SoftDeleteCourseParams struct {
	DeletedAt sql.NullTime
	CourseID  uuid.UUID
}

func (q *Queries) SoftDeleteCourse(ctx context.Context, arg SoftDeleteCourseParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteCourse, arg.DeletedAt, arg.CourseID)
	return err
}

const updateCourse = `-- name: UpdateCourse :exec
UPDATE
    t_courses
SET
    language_id =  COALESCE($1::TEXT, language_id),
    programming_language_id =  COALESCE($2::TEXT, programming_language_id),
    reward_id =  COALESCE($3::TEXT, reward_id),
    reward_amount =  COALESCE($4::INTEGER, reward_amount),
    title =  COALESCE($5::TEXT, title),
    description =  COALESCE($6::TEXT, description),
    image_path =  COALESCE($7::TEXT, image_path)
WHERE
    id = $8
`

type UpdateCourseParams struct {
	LanguageID            sql.NullString
	ProgrammingLanguageID sql.NullString
	RewardID              sql.NullString
	RewardAmount          sql.NullInt32
	Title                 sql.NullString
	Description           sql.NullString
	ImagePath             sql.NullString
	CourseID              uuid.UUID
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) error {
	_, err := q.db.ExecContext(ctx, updateCourse,
		arg.LanguageID,
		arg.ProgrammingLanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.ImagePath,
		arg.CourseID,
	)
	return err
}
