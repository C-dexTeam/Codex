// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: userCourse.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addCourseToUser = `-- name: AddCourseToUser :exec
INSERT INTO t_user_courses 
    (user_auth_id, course_id, progress)
VALUES 
    ($1, $2, 
     (
        SELECT COALESCE(
               (COUNT(CASE WHEN isFinished = TRUE THEN 1 END) * 100.0 / 
                NULLIF((SELECT COUNT(*) FROM t_chapters as c WHERE c.course_id = $2 AND c.deleted_at IS NULL), 0)
               ), 0
           )
        FROM t_user_chapters as uc
        WHERE uc.user_auth_id = $1 AND uc.course_id = $2
     )
    )
`

type AddCourseToUserParams struct {
	UserAuthID uuid.UUID
	CourseID   uuid.UUID
}

func (q *Queries) AddCourseToUser(ctx context.Context, arg AddCourseToUserParams) error {
	_, err := q.db.ExecContext(ctx, addCourseToUser, arg.UserAuthID, arg.CourseID)
	return err
}

const checkUserCourseByID = `-- name: CheckUserCourseByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_user_courses AS l
        WHERE l.course_id = $1 AND l.user_auth_id = $2
    ) THEN true
    ELSE false
END AS exists
`

type CheckUserCourseByIDParams struct {
	CourseID   uuid.UUID
	UserAuthID uuid.UUID
}

func (q *Queries) CheckUserCourseByID(ctx context.Context, arg CheckUserCourseByIDParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserCourseByID, arg.CourseID, arg.UserAuthID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateUserCourseProgress = `-- name: UpdateUserCourseProgress :one
UPDATE t_user_courses
SET progress = (
    SELECT COALESCE(
               (COUNT(CASE WHEN isFinished = TRUE THEN 1 END) * 100.0 / 
                (SELECT COUNT(*) FROM t_chapters as c WHERE c.course_id = $1 AND c.deleted_at IS NULL)
               ), 0
           )
    FROM t_user_chapters as uc
    WHERE uc.user_auth_id = $2 AND uc.course_id = $1
)
WHERE 
    user_auth_id = $2 AND course_id = $1
RETURNING progress
`

type UpdateUserCourseProgressParams struct {
	CourseID   uuid.UUID
	UserAuthID uuid.UUID
}

func (q *Queries) UpdateUserCourseProgress(ctx context.Context, arg UpdateUserCourseProgressParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, updateUserCourseProgress, arg.CourseID, arg.UserAuthID)
	var progress sql.NullInt32
	err := row.Scan(&progress)
	return progress, err
}

const userCourse = `-- name: UserCourse :one
SELECT 
    user_auth_id, course_id, progress, created_at
FROM 
    t_user_courses
WHERE course_id = $1 AND user_auth_id = $2
`

type UserCourseParams struct {
	CourseID   uuid.UUID
	UserAuthID uuid.UUID
}

func (q *Queries) UserCourse(ctx context.Context, arg UserCourseParams) (TUserCourse, error) {
	row := q.db.QueryRowContext(ctx, userCourse, arg.CourseID, arg.UserAuthID)
	var i TUserCourse
	err := row.Scan(
		&i.UserAuthID,
		&i.CourseID,
		&i.Progress,
		&i.CreatedAt,
	)
	return i, err
}

const userCourses = `-- name: UserCourses :many
SELECT 
    uc.user_auth_id,
    uc.course_id,
    c.title,
    uc.progress,
    COUNT(ucp.id) AS completed_chapters,
    (SELECT COUNT(*) FROM t_user_chapters WHERE course_id = uc.course_id) AS total_chapters
FROM 
    t_user_courses uc
INNER JOIN 
    t_courses c ON uc.course_id = c.id
LEFT JOIN 
    t_user_chapters ucp 
    ON ucp.course_id = uc.course_id AND ucp.isFinished = true
WHERE 
    uc.user_auth_id = $1 AND c.deleted_at IS NULL
GROUP BY 
    uc.user_auth_id, uc.course_id, c.title, c.description, uc.progress
`

type UserCoursesRow struct {
	UserAuthID        uuid.UUID
	CourseID          uuid.UUID
	Title             string
	Progress          sql.NullInt32
	CompletedChapters int64
	TotalChapters     int64
}

func (q *Queries) UserCourses(ctx context.Context, userAuthID uuid.UUID) ([]UserCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, userCourses, userAuthID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserCoursesRow
	for rows.Next() {
		var i UserCoursesRow
		if err := rows.Scan(
			&i.UserAuthID,
			&i.CourseID,
			&i.Title,
			&i.Progress,
			&i.CompletedChapters,
			&i.TotalChapters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
