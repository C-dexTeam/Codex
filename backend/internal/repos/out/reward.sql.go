// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: reward.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createReward = `-- name: CreateReward :exec
INSERT INTO
    t_rewards (reward_type, symbol, name, description, image_path, uri)
VALUES
    ($1, $2, $3, $4, $5, $6)
`

type CreateRewardParams struct {
	RewardType  string
	Symbol      string
	Name        string
	Description string
	ImagePath   string
	Uri         string
}

func (q *Queries) CreateReward(ctx context.Context, arg CreateRewardParams) error {
	_, err := q.db.ExecContext(ctx, createReward,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.ImagePath,
		arg.Uri,
	)
	return err
}

const deleteReward = `-- name: DeleteReward :exec
DELETE FROM
    t_rewards
WHERE
    id = $1
`

func (q *Queries) DeleteReward(ctx context.Context, rewardID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteReward, rewardID)
	return err
}

const getReward = `-- name: GetReward :one
SELECT 
    r.id, r.reward_type, r.symbol, r.name, r.description, r.image_path, r.uri,
    (SELECT id, reward_id, trait_type, value FROM t_attributes LIMIT $2 OFFSET $1) AS attributes
FROM 
    t_rewards as r
WHERE
    r.id = $3
`

type GetRewardParams struct {
	Off      int32
	Lim      int32
	RewardID uuid.UUID
}

type GetRewardRow struct {
	ID          uuid.UUID
	RewardType  string
	Symbol      string
	Name        string
	Description string
	ImagePath   string
	Uri         string
	Attributes  uuid.UUID
}

func (q *Queries) GetReward(ctx context.Context, arg GetRewardParams) (GetRewardRow, error) {
	row := q.db.QueryRowContext(ctx, getReward, arg.Off, arg.Lim, arg.RewardID)
	var i GetRewardRow
	err := row.Scan(
		&i.ID,
		&i.RewardType,
		&i.Symbol,
		&i.Name,
		&i.Description,
		&i.ImagePath,
		&i.Uri,
		&i.Attributes,
	)
	return i, err
}

const getRewards = `-- name: GetRewards :many
SELECT 
    r.id, r.reward_type, r.symbol, r.name, r.description, r.image_path, r.uri
FROM 
    t_rewards as r
WHERE
    ($1::text IS NULL OR us.id = $1) AND
    ($2::text IS NULL OR us.reward_type = $2) AND
    ($3::text IS NULL OR symbol ILIKE '%' || $3::text || '%') AND
    ($4::text IS NULL OR name ILIKE '%' || $4::text || '%') AND
    ($5::text IS NULL OR description ILIKE '%' || $5::text || '%')
LIMIT $7 OFFSET $6
`

type GetRewardsParams struct {
	ID          sql.NullString
	RewardType  sql.NullString
	Symbol      sql.NullString
	Name        sql.NullString
	Description sql.NullString
	Off         int32
	Lim         int32
}

func (q *Queries) GetRewards(ctx context.Context, arg GetRewardsParams) ([]TReward, error) {
	rows, err := q.db.QueryContext(ctx, getRewards,
		arg.ID,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TReward
	for rows.Next() {
		var i TReward
		if err := rows.Scan(
			&i.ID,
			&i.RewardType,
			&i.Symbol,
			&i.Name,
			&i.Description,
			&i.ImagePath,
			&i.Uri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReward = `-- name: UpdateReward :exec
UPDATE
    t_rewards
SET
    reward_type =  COALESCE($1::TEXT, reward_type),
    symbol =  COALESCE($2::TEXT, symbol),
    name =  COALESCE($3::TEXT, name),
    description =  COALESCE($4::TEXT, description),
    image_path =  COALESCE($5::TEXT, image_path),
    uri =  COALESCE($6::TEXT, uri)
WHERE
    id = $7
`

type UpdateRewardParams struct {
	RewardType  sql.NullString
	Symbol      sql.NullString
	Name        sql.NullString
	Description sql.NullString
	ImagePath   sql.NullString
	Uri         sql.NullString
	RewardID    uuid.UUID
}

func (q *Queries) UpdateReward(ctx context.Context, arg UpdateRewardParams) error {
	_, err := q.db.ExecContext(ctx, updateReward,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.ImagePath,
		arg.Uri,
		arg.RewardID,
	)
	return err
}
