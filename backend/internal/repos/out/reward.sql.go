// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reward.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkRewardByID = `-- name: CheckRewardByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_rewards AS l
        WHERE l.id = $1 
    ) THEN true
    ELSE false
END AS exists
`

func (q *Queries) CheckRewardByID(ctx context.Context, rewardID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRewardByID, rewardID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createReward = `-- name: CreateReward :one
INSERT INTO
    t_rewards (reward_type, symbol, name, description, image_path, uri, seller_fee)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateRewardParams struct {
	RewardType  string
	Symbol      string
	Name        string
	Description string
	ImagePath   sql.NullString
	Uri         sql.NullString
	SellerFee   int32
}

func (q *Queries) CreateReward(ctx context.Context, arg CreateRewardParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createReward,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.ImagePath,
		arg.Uri,
		arg.SellerFee,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteReward = `-- name: DeleteReward :exec
DELETE FROM
    t_rewards
WHERE
    id = $1
`

func (q *Queries) DeleteReward(ctx context.Context, rewardID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteReward, rewardID)
	return err
}

const getReward = `-- name: GetReward :one
SELECT 
    r.id, r.reward_type, r.symbol, r.name, r.description, r.seller_fee, r.image_path, r.uri
FROM 
    t_rewards as r
WHERE
    r.id = $1
`

func (q *Queries) GetReward(ctx context.Context, rewardID uuid.UUID) (TReward, error) {
	row := q.db.QueryRowContext(ctx, getReward, rewardID)
	var i TReward
	err := row.Scan(
		&i.ID,
		&i.RewardType,
		&i.Symbol,
		&i.Name,
		&i.Description,
		&i.SellerFee,
		&i.ImagePath,
		&i.Uri,
	)
	return i, err
}

const getRewards = `-- name: GetRewards :many
SELECT 
    r.id, r.reward_type, r.symbol, r.name, r.description, r.seller_fee, r.image_path, r.uri 
FROM 
    t_rewards as r
WHERE
    ($1::UUID IS NULL OR r.id = $1::UUID) AND
    ($2::text IS NULL OR r.reward_type = $2) AND
    ($3::text IS NULL OR r.symbol ILIKE '%' || $3::text || '%') AND
    ($4::text IS NULL OR r.name ILIKE '%' || $4::text || '%') AND
    ($5::text IS NULL OR r.description ILIKE '%' || $5::text || '%')
LIMIT $7 OFFSET $6
`

type GetRewardsParams struct {
	ID          uuid.NullUUID
	RewardType  sql.NullString
	Symbol      sql.NullString
	Name        sql.NullString
	Description sql.NullString
	Off         int32
	Lim         int32
}

func (q *Queries) GetRewards(ctx context.Context, arg GetRewardsParams) ([]TReward, error) {
	rows, err := q.db.QueryContext(ctx, getRewards,
		arg.ID,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TReward
	for rows.Next() {
		var i TReward
		if err := rows.Scan(
			&i.ID,
			&i.RewardType,
			&i.Symbol,
			&i.Name,
			&i.Description,
			&i.SellerFee,
			&i.ImagePath,
			&i.Uri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReward = `-- name: UpdateReward :exec
UPDATE
    t_rewards
SET
    reward_type =  COALESCE($1::TEXT, reward_type),
    symbol =  COALESCE($2::TEXT, symbol),
    name =  COALESCE($3::TEXT, name),
    description =  COALESCE($4::TEXT, description),
    image_path =  COALESCE($5::TEXT, image_path),
    uri =  COALESCE($6::TEXT, uri),
    seller_fee =  COALESCE($7::INTEGER, seller_fee)
WHERE
    id = $8
`

type UpdateRewardParams struct {
	RewardType  sql.NullString
	Symbol      sql.NullString
	Name        sql.NullString
	Description sql.NullString
	ImagePath   sql.NullString
	Uri         sql.NullString
	SellerFee   sql.NullInt32
	RewardID    uuid.UUID
}

func (q *Queries) UpdateReward(ctx context.Context, arg UpdateRewardParams) error {
	_, err := q.db.ExecContext(ctx, updateReward,
		arg.RewardType,
		arg.Symbol,
		arg.Name,
		arg.Description,
		arg.ImagePath,
		arg.Uri,
		arg.SellerFee,
		arg.RewardID,
	)
	return err
}
