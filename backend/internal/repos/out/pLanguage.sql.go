// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: pLanguage.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkPLanguageByID = `-- name: CheckPLanguageByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_programming_languages AS l
        WHERE l.id = $1
    ) THEN true
    ELSE false
END AS exists
`

func (q *Queries) CheckPLanguageByID(ctx context.Context, programmingLanguageID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkPLanguageByID, programmingLanguageID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createPLanguage = `-- name: CreatePLanguage :one
INSERT INTO
    t_programming_languages (language_id, name, description, download_cmd, compile_cmd, image_path, file_extention, monaco_editor)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreatePLanguageParams struct {
	LanguageID    uuid.UUID
	Name          string
	Description   string
	DownloadCmd   string
	CompileCmd    string
	ImagePath     string
	FileExtention string
	MonacoEditor  string
}

func (q *Queries) CreatePLanguage(ctx context.Context, arg CreatePLanguageParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPLanguage,
		arg.LanguageID,
		arg.Name,
		arg.Description,
		arg.DownloadCmd,
		arg.CompileCmd,
		arg.ImagePath,
		arg.FileExtention,
		arg.MonacoEditor,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deletePLanguage = `-- name: DeletePLanguage :exec
DELETE FROM
    t_programming_languages
WHERE
    id = $1
`

func (q *Queries) DeletePLanguage(ctx context.Context, programmingLanguageID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePLanguage, programmingLanguageID)
	return err
}

const getPLanguageByID = `-- name: GetPLanguageByID :one
SELECT 
    pl.id, pl.language_id, pl.name, pl.description, pl.download_cmd, pl.compile_cmd, pl.image_path,
    pl.file_extention, pl.monaco_editor, pl.created_at
FROM 
    t_programming_languages as pl
WHERE
    pl.id = $1
`

func (q *Queries) GetPLanguageByID(ctx context.Context, programmingLanguageID uuid.UUID) (TProgrammingLanguage, error) {
	row := q.db.QueryRowContext(ctx, getPLanguageByID, programmingLanguageID)
	var i TProgrammingLanguage
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.Name,
		&i.Description,
		&i.DownloadCmd,
		&i.CompileCmd,
		&i.ImagePath,
		&i.FileExtention,
		&i.MonacoEditor,
		&i.CreatedAt,
	)
	return i, err
}

const getPLanguages = `-- name: GetPLanguages :many
SELECT 
    pl.id, pl.language_id, pl.name, pl.description, pl.download_cmd, pl.compile_cmd, pl.image_path,
    pl.file_extention, pl.monaco_editor, pl.created_at
FROM 
    t_programming_languages as pl
WHERE
    ($1::UUID IS NULL OR pl.id = $1::UUID) AND
    ($2::UUID IS NULL OR pl.language_id = $2::UUID) AND
    ($3::text IS NULL OR pl.name ILIKE '%' || $3::text || '%') AND
    ($4::text IS NULL OR pl.description ILIKE '%' || $4::text || '%')
LIMIT $6 OFFSET $5
`

type GetPLanguagesParams struct {
	ID          uuid.NullUUID
	LanguageID  uuid.NullUUID
	Name        sql.NullString
	Description sql.NullString
	Off         int32
	Lim         int32
}

func (q *Queries) GetPLanguages(ctx context.Context, arg GetPLanguagesParams) ([]TProgrammingLanguage, error) {
	rows, err := q.db.QueryContext(ctx, getPLanguages,
		arg.ID,
		arg.LanguageID,
		arg.Name,
		arg.Description,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TProgrammingLanguage
	for rows.Next() {
		var i TProgrammingLanguage
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Name,
			&i.Description,
			&i.DownloadCmd,
			&i.CompileCmd,
			&i.ImagePath,
			&i.FileExtention,
			&i.MonacoEditor,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePLanguage = `-- name: UpdatePLanguage :exec
UPDATE
    t_programming_languages
SET
    language_id =  COALESCE($1::UUID, language_id),
    name =  COALESCE($2::TEXT, name),
    description =  COALESCE($3::TEXT, description),
    download_cmd =  COALESCE($4::TEXT, download_cmd),
    compile_cmd =  COALESCE($5::TEXT, compile_cmd),
    image_path =  COALESCE($6::TEXT, image_path),
    file_extention =  COALESCE($7::TEXT, file_extention),
    monaco_editor =  COALESCE($8::TEXT, monaco_editor)
WHERE
    id = $9
`

type UpdatePLanguageParams struct {
	LanguageID            uuid.NullUUID
	Name                  sql.NullString
	Description           sql.NullString
	DownloadCmd           sql.NullString
	CompileCmd            sql.NullString
	ImagePath             sql.NullString
	FileExtention         sql.NullString
	MonacoEditor          sql.NullString
	ProgrammingLanguageID uuid.UUID
}

func (q *Queries) UpdatePLanguage(ctx context.Context, arg UpdatePLanguageParams) error {
	_, err := q.db.ExecContext(ctx, updatePLanguage,
		arg.LanguageID,
		arg.Name,
		arg.Description,
		arg.DownloadCmd,
		arg.CompileCmd,
		arg.ImagePath,
		arg.FileExtention,
		arg.MonacoEditor,
		arg.ProgrammingLanguageID,
	)
	return err
}
