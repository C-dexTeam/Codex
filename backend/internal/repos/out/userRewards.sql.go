// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: userRewards.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addRewardToUser = `-- name: AddRewardToUser :exec
INSERT INTO t_user_rewards
    (user_auth_id, course_id, chapter_id, reward_id)
VALUES
    ($1, $2, $3, $4)
`

type AddRewardToUserParams struct {
	UserAuthID uuid.UUID
	CourseID   uuid.UUID
	ChapterID  uuid.NullUUID
	RewardID   uuid.UUID
}

func (q *Queries) AddRewardToUser(ctx context.Context, arg AddRewardToUserParams) error {
	_, err := q.db.ExecContext(ctx, addRewardToUser,
		arg.UserAuthID,
		arg.CourseID,
		arg.ChapterID,
		arg.RewardID,
	)
	return err
}

const checkUserReward = `-- name: CheckUserReward :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_user_rewards AS l
        WHERE
            l.user_auth_id = $1 AND course_id = $2 AND chapter_id = $3 AND reward_id = $4
    ) THEN true
    ELSE false
END AS exists
`

type CheckUserRewardParams struct {
	UserAuthID uuid.UUID
	CourseID   uuid.UUID
	ChapterID  uuid.NullUUID
	RewardID   uuid.UUID
}

func (q *Queries) CheckUserReward(ctx context.Context, arg CheckUserRewardParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserReward,
		arg.UserAuthID,
		arg.CourseID,
		arg.ChapterID,
		arg.RewardID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userRewards = `-- name: UserRewards :many
SELECT
    r.id, r.reward_type, r.symbol, r.name, r.description, r.image_path, r.uri, 
    ur.created_at AS earned_date
FROM
    t_rewards AS r
INNER JOIN 
    t_user_rewards AS ur ON r.id = ur.reward_id
WHERE 
    ur.user_auth_id = $1
ORDER BY 
    ur.created_at DESC
LIMIT 
    $3 OFFSET $2
`

type UserRewardsParams struct {
	UserAuthID uuid.UUID
	Off        int32
	Lim        int32
}

type UserRewardsRow struct {
	ID          uuid.UUID
	RewardType  string
	Symbol      string
	Name        string
	Description string
	ImagePath   sql.NullString
	Uri         sql.NullString
	EarnedDate  sql.NullTime
}

func (q *Queries) UserRewards(ctx context.Context, arg UserRewardsParams) ([]UserRewardsRow, error) {
	rows, err := q.db.QueryContext(ctx, userRewards, arg.UserAuthID, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRewardsRow
	for rows.Next() {
		var i UserRewardsRow
		if err := rows.Scan(
			&i.ID,
			&i.RewardType,
			&i.Symbol,
			&i.Name,
			&i.Description,
			&i.ImagePath,
			&i.Uri,
			&i.EarnedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
