// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: userAuth.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkUserAuthByID = `-- name: CheckUserAuthByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_users_auth AS l
        WHERE l.id = $1
    ) THEN true
    ELSE false
END AS exists
`

func (q *Queries) CheckUserAuthByID(ctx context.Context, userAuthID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserAuthByID, userAuthID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countUserByName = `-- name: CountUserByName :one
SELECT COUNT(*) FROM t_users_auth WHERE username = $1
`

func (q *Queries) CountUserByName(ctx context.Context, username sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserByName, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserAuth = `-- name: CreateUserAuth :one
INSERT INTO t_users_auth 
    (public_key, username, email, password)
VALUES 
    ($1, $2, $3, $4)
RETURNING id
`

type CreateUserAuthParams struct {
	PublicKey sql.NullString
	Username  sql.NullString
	Email     sql.NullString
	Password  sql.NullString
}

func (q *Queries) CreateUserAuth(ctx context.Context, arg CreateUserAuthParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserAuth,
		arg.PublicKey,
		arg.Username,
		arg.Email,
		arg.Password,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserAuthByID = `-- name: GetUserAuthByID :one
SELECT 
    id, public_key, username, email, password, deleted_at
FROM 
    t_users_auth
WHERE 
    id = $1
`

func (q *Queries) GetUserAuthByID(ctx context.Context, userAuthID uuid.UUID) (TUsersAuth, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthByID, userAuthID)
	var i TUsersAuth
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.DeletedAt,
	)
	return i, err
}

const getUserAuthByUsername = `-- name: GetUserAuthByUsername :one
SELECT 
    id, public_key, username, email, password, deleted_at
FROM 
    t_users_auth 
WHERE 
    username = $1
`

func (q *Queries) GetUserAuthByUsername(ctx context.Context, username sql.NullString) (TUsersAuth, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthByUsername, username)
	var i TUsersAuth
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.DeletedAt,
	)
	return i, err
}

const getUsersAuth = `-- name: GetUsersAuth :many
SELECT 
    us.id, us.public_key, us.username, us.email, us.password, us.deleted_at
FROM 
    t_users_auth as us
WHERE
    ($1::UUID IS NULL OR us.id = $1::UUID) AND
    ($2::TEXT IS NULL OR us.public_key = $2::TEXT) AND
    ($3::TEXT IS NULL OR username ILIKE '%' || $3::TEXT || '%') AND
    ($4::TEXT IS NULL OR email ILIKE '%' || $4::TEXT || '%') AND
    deleted_at IS NULL
LIMIT $6 OFFSET $5
`

type GetUsersAuthParams struct {
	ID        uuid.NullUUID
	PublicKey sql.NullString
	Username  sql.NullString
	Email     sql.NullString
	Off       int32
	Lim       int32
}

func (q *Queries) GetUsersAuth(ctx context.Context, arg GetUsersAuthParams) ([]TUsersAuth, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAuth,
		arg.ID,
		arg.PublicKey,
		arg.Username,
		arg.Email,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUsersAuth
	for rows.Next() {
		var i TUsersAuth
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE
    t_users_auth
SET
    deleted_at = CURRENT_TIMESTAMP
WHERE
    id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, userAuthID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, userAuthID)
	return err
}

const updateUserAuth = `-- name: UpdateUserAuth :exec
UPDATE
    t_users_auth
SET
    public_key = COALESCE($1::TEXT, public_key),
    username = COALESCE($2::TEXT, username),
    email = COALESCE($3::TEXT, email)
WHERE
    id = $4
`

type UpdateUserAuthParams struct {
	PublicKey  sql.NullString
	Username   sql.NullString
	Email      sql.NullString
	UserAuthID uuid.UUID
}

func (q *Queries) UpdateUserAuth(ctx context.Context, arg UpdateUserAuthParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAuth,
		arg.PublicKey,
		arg.Username,
		arg.Email,
		arg.UserAuthID,
	)
	return err
}
