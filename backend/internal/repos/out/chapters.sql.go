// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: chapters.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkChapterByID = `-- name: CheckChapterByID :one
SELECT 
CASE 
    WHEN EXISTS (
        SELECT 1 
        FROM t_chapters AS l
        WHERE l.id = $1 AND l.deleted_at IS NULL
    ) THEN true
    ELSE false
END AS exists
`

func (q *Queries) CheckChapterByID(ctx context.Context, chapterID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkChapterByID, chapterID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChapter = `-- name: CreateChapter :one
INSERT INTO
    t_chapters (course_id, language_id, reward_id, reward_amount, title, description, content,
    func_name, frontend_template, docker_template, grants_experience, active, chapter_order)
VALUES
   ($1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13)
RETURNING id
`

type CreateChapterParams struct {
	CourseID         uuid.UUID
	LanguageID       uuid.UUID
	RewardID         uuid.NullUUID
	RewardAmount     int32
	Title            string
	Description      string
	Content          string
	FuncName         string
	FrontendTemplate string
	DockerTemplate   string
	GrantsExperience bool
	Active           bool
	ChapterOrder     int32
}

func (q *Queries) CreateChapter(ctx context.Context, arg CreateChapterParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createChapter,
		arg.CourseID,
		arg.LanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.FuncName,
		arg.FrontendTemplate,
		arg.DockerTemplate,
		arg.GrantsExperience,
		arg.Active,
		arg.ChapterOrder,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getChapter = `-- name: GetChapter :one
SELECT
    c.id, c.course_id, c.language_id, c.reward_id, c.reward_amount, c.title, c.description, c.content,
    c.func_name, c.frontend_template, c.docker_template, c.grants_experience, c.active,
    c.chapter_order, c.created_at, c.deleted_at
FROM
    t_chapters as c
WHERE
    c.id = $1
`

func (q *Queries) GetChapter(ctx context.Context, chapterID uuid.UUID) (TChapter, error) {
	row := q.db.QueryRowContext(ctx, getChapter, chapterID)
	var i TChapter
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.LanguageID,
		&i.RewardID,
		&i.RewardAmount,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.FuncName,
		&i.FrontendTemplate,
		&i.DockerTemplate,
		&i.GrantsExperience,
		&i.Active,
		&i.ChapterOrder,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getChapters = `-- name: GetChapters :many
SELECT 
    c.id, c.course_id, c.language_id, c.reward_id, c.reward_amount, c.title, c.description, c.content,
    c.func_name, c.frontend_template, c.docker_template, c.grants_experience, c.active,
    c.chapter_order, c.created_at, c.deleted_at
FROM 
    t_chapters as c
WHERE
    ($1::UUID IS NULL OR c.id = $1::UUID) AND
    ($2::UUID IS NULL OR c.course_id = $2::UUID) AND
    ($3::UUID IS NULL OR c.language_id = $3::UUID) AND
    ($4::UUID IS NULL OR c.reward_id = $4::UUID) AND
    ($5::text IS NULL OR c.title ILIKE '%' || $5::text || '%') AND
    deleted_at IS NULL
ORDER BY
    c.chapter_order  ASC
LIMIT 
    $7 OFFSET $6
`

type GetChaptersParams struct {
	ID         uuid.NullUUID
	CourseID   uuid.NullUUID
	LanguageID uuid.NullUUID
	RewardID   uuid.NullUUID
	Title      sql.NullString
	Off        int32
	Lim        int32
}

func (q *Queries) GetChapters(ctx context.Context, arg GetChaptersParams) ([]TChapter, error) {
	rows, err := q.db.QueryContext(ctx, getChapters,
		arg.ID,
		arg.CourseID,
		arg.LanguageID,
		arg.RewardID,
		arg.Title,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TChapter
	for rows.Next() {
		var i TChapter
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.LanguageID,
			&i.RewardID,
			&i.RewardAmount,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.FuncName,
			&i.FrontendTemplate,
			&i.DockerTemplate,
			&i.GrantsExperience,
			&i.Active,
			&i.ChapterOrder,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteChapter = `-- name: SoftDeleteChapter :exec
UPDATE
    t_chapters
SET
    deleted_at = CURRENT_TIMESTAMP
WHERE  
    id = $1
`

func (q *Queries) SoftDeleteChapter(ctx context.Context, chapterID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteChapter, chapterID)
	return err
}

const updateChapter = `-- name: UpdateChapter :exec
UPDATE
    t_chapters
SET
    course_id = COALESCE($1, course_id),
    language_id = COALESCE($2, language_id),
    reward_id = COALESCE($3, reward_id),
    reward_amount =  COALESCE($4, reward_amount),
    title =  COALESCE($5, title),
    description =  COALESCE($6, description),
    content =  COALESCE($7, content),
    func_name =  COALESCE($8, func_name),
    frontend_template =  COALESCE($9, frontend_template),
    docker_template =  COALESCE($10, docker_template),
    grants_experience =  COALESCE($11::BOOLEAN, grants_experience),
    active =  COALESCE($12::BOOLEAN, active)
WHERE
    id = $13
`

type UpdateChapterParams struct {
	CourseID         uuid.NullUUID
	LanguageID       uuid.NullUUID
	RewardID         uuid.NullUUID
	RewardAmount     sql.NullInt32
	Title            sql.NullString
	Description      sql.NullString
	Content          sql.NullString
	FuncName         sql.NullString
	FrontendTemplate sql.NullString
	DockerTemplate   sql.NullString
	GrantsExperience sql.NullBool
	Active           sql.NullBool
	ChapterID        uuid.UUID
}

func (q *Queries) UpdateChapter(ctx context.Context, arg UpdateChapterParams) error {
	_, err := q.db.ExecContext(ctx, updateChapter,
		arg.CourseID,
		arg.LanguageID,
		arg.RewardID,
		arg.RewardAmount,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.FuncName,
		arg.FrontendTemplate,
		arg.DockerTemplate,
		arg.GrantsExperience,
		arg.Active,
		arg.ChapterID,
	)
	return err
}
